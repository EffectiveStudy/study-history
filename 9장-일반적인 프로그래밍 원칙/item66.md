### item66 - 네이티브 메서드는 신중히 사용하라

### 네이티브 메서드란?

C 나 C++같은 네이티브 프로그래밍으로 작성한 메서드

### 사용처
* 성능 이슈가 있는 경우 (예 : 바이너리 데이터 처리)
* 운영 체제와 밀접하게 연관된 작업 (예 : 파일 및 디렉토리 조작)
* 하드웨어와 밀접하게 연관된 작업 (예 : 하드웨어 제어)


즉, JNI는 네이티브메서드를 호출하는 기술이다.


**JNI가 만들어질 당시, 자바는 ...**
1. 자바는 원칙적으로 바이트코드를 인터프리트해 수행되기 때문에, 자바기술이 발전한다고 해도 플랫폼에 종속적인 기계어 코드인 네이티브 코드보다 느림
2. Legacy와 연계 문제도 있고, 플랫폼에 따라 제공되는 서비스를 이용하기 위함.
3. 자바의 클래스는 특정 플랫폼에서 제공하는 고유의 서비스 기능을 모두 포함할 수 없다.

---
### 자바의 현재는?

자바가 발전하며, 하부 플랫폼의 기능을 자바로 흡수하며, 네이티브 코드를 사용할 필요가 줄어들고 있다.

ex) java.math가 처음 추가 될 때는 BigInteger는 C로 작성한 네이티브 언어였다.
하지만 튜닝 후 원래 네이티브 언어일 때보다 더 빨라짐

### 네이티브 메서드는 현재?

GNU 다중 정밀 연산 라이브러리를 필두로된 작업이 계속되어왔다.

-----

### 네이티브 언어의 단점
* 네이티브 언어가 안전하지 않다(IIEM50) - 네이티브 메소드는 자바 메소드처럼 동일한 보호를 보장받지 못한다.
* 일단 C++코드에 들어가게 되면, 자바에서의 모든 것이 백지화되고 메모리 추적, 포인터의 사용, 그리고 배열 바운딩에 의한 C++ 버그들이 발생할 수 있다.
* 자바보다 플랫폼을 많이 타서 이식성도 낮다
* 디버깅도 어렵다
* 속도가 오히려 느려진다 - GC가 자동 회수를 하지 못한다.
* 추적도 못한다(ITEM8)
* 자바코드와 네이티브 경계를 넘을 때, 비용이 추가됨(글루코드)



### 현재 많이 쓰이는 native method

System.arraycopy(): 배열의 복사

Object.hashCode(): 객체의 해시 코드 계산

System.currentTimeMillis(): 현재 시간을 밀리초 단위로 반환

https://roughexistence.tistory.com/81
