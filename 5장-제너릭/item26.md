### item 26 - 로 타입은 사용하지 말라

#### 제너릭 타입
    클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제너릭 클래스 혹은 제너릭 인터페이스라고 한다.

#### 로타입??
 ``` java
List a = new ArrayList();
```
* 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않는 타입
* 타입 정보가 전부 지워진 것처럼 동작한다<br>
예를 들어 List< String >에서 "List"가 제너릭 타입의 로타입이다.
<br> 제너릭이 도래하기 전 호환을 위해 만들어짐.

#### 로타입을 사용하지 말자!![TEST]
1. 아무 인스턴스나 들어갈 수 있다 => 컴파일 에러에서 잡지 못함.
2. 제너릭이 안겨주는 안정성과 표현력을 모두 잃게 됨.

#### List<Object>[TEST]

* 로타입이랑 비슷한 기능을 해주는 List < Object>는 허용된다. 
* 둘의 차이가 무엇인가?<br> List는 제너릭 타입에서 발을 완전히 뺸 것이고, List < Object>는 모든 타입을 허용한다는 의미를 컴파일러에 명확히 명시한 것.

    <br> 하지만 Object타입을 사용하면 문제가 있다.<br>
    모든 타입을 받으려고 선언한 List< Object>는 제너릭의 하위 타입 규칙 때문에 List< String>을 받지 못하고 컴파일 에러가 발생한다.

    ```
    Object과 String이 부모-자식이라 될것 같지만.
    List<Object>에는 어떤 타입의 값도 넣을 수 있지만 List<String>은 문자열만 넣을 수 있다.
    List<String>을 List<Object> 하위 타입이라고 생각한다면
    List<String>은 자신의 상위 타입 List<Object>의 모든 일을 할 수 없기 때문에 리스코프 치환 원칙에 어긋난다.
    ```


#### 나는 모든 타입을 받고 싶은데? => 비한정 와일드 카드를 사용하자[TEST]
* 로 타입은 안전하지 않고, 와일드 카드는 안전하다. 로 타입 컬렉션은 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다
* List< ?>는 모든 타입의 상위 타입 
  * 와일드 카드는 어떤 원소도 넣을 수 없다(null제외)
  이유 : 해당 리스트 안에 어떤 값이들어있는지 모르기 때문이다.<br> 만약 추가를 허용한다면, Integer list에 double을 넣을 수도 있기 때문에 제네릭의 타입 안정성을 위배한다.



#### 예외 사항
1. class 리터럴에는 로 타입을 써야한다. 예를 들면 List<String>.class와 같은건 허용하지 않는다.
2. instanceof 연산자에서 로타입을 써야한다. 런타임에는 매개변수화 정보가 지워진다. 컴파일 단계에선 잘못된 타입에 대한 체크가 끝나기 때문
instanceof List와 instanceof List<?>은 똑같이 동작한다

   
