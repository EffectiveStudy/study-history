
# TL;DR

직렬화 지원은 쉽다. 하지만 호환성문제, 보안문제가 생길수 있으니, 신중해야 한다.

구체적으론, 다음 상황에서 신중해야 하며, `커스텀 직렬화`를 고려하는 것이 좋다.

1) 한클래스의 여러 버전과 상호작용하는 경우.
2) 서버가 신뢰할수 없는 데이터에 노출될 수 있는 경우.
3) 클래스가 상속가능한 경우.

# Q. 직렬화의 문제점?


## 1) 호환성 문제

> 한번 직렬화를 구현하면, versioning 해야 한다.

마치 API가 한번 공개되면 예전 버전과 호환성을 유지해주어야 하는 것처럼, 

직렬화를 구현한 클래스가 널리 퍼지면, 해당 직렬화 형태로 버저닝이 필요해진다.



## 2) 클래스 캡슐화가 깨진다 (자바 기본방식 이용시)

> 자바 기본 방식으로 직렬화하면 private 필드도 그대로 공개된다. 
>
> 즉, 캡슐화가 깨지고 내부 구현 방식에 의존하게 된다.

## 3) serivalVersionUID 자동생성시 호환성문제

> 해당 고유식별번호를 설정하지 않은 경우, 컴파일러가 자동으로 생성. 
> 
> 클래스가 수정된다면 고유식별번호도 자동으로 바뀌어 호환성이 깨진다.


모든 직렬화된 클래스는 `고유 식별 번호` (`static final long serialVersionUID`) 가 필요한데,

직렬화는 구현했지만 해당 번호를 설정하지 않았다면, 시스템이 자동으로 생성한다.


구체적으론, SHA-1를 이용하며, 생성 재료로서 `클래스 이름, 구현 인터페이스들, 클래스 멤버`을 이용한다.

문제는, 클래스가 수정된다면 해당 번호도 바뀌게 되어 호환성이 깨지게 된다는 것이다.


## 4) 보안 취약 문제

> 객체는 생성자를 이용해 만드는게 기본인데, 역직렬화(`readObject`) 는 언어의 기본 메커니즘을 우회하여 객체를 바로 생성한다. 
> 
> 따라서, 불변식 깨짐과 허가되지 않은 접근에 노출에 위험된다. 

[ 예제 : Member클래스 ]

- 불변식 : age는 마이너스 값을 가질수 없다.

- 하지만, 역직렬화시에는 마이너스 값이 들어가도 이를 걸러 낼 수 없다.

- (역직렬화 방어 기법 중 하나인 직렬화 프록시 패턴으로 극복 가능)

```java
class Member implements Serializable {
    private static final long serialVersionUID = 1L;
    private int age;

    public Member(int age) {
        if(age < 0){
            throw new IllegalArgumentException();
        }
        this.age = age;
    }
}
```


## 5) 테스트양 증가

> 상위버전과 하위버전의 직렬화, 역직렬화 호환성 검증 테스트가 필요해진다.


# Advice

> 상속용 클래스(including 인터페이스), 내부클래스는 직렬화 금.지.

## Advice1 : 상속용 클래스는 직렬화 금지

> 상속시, 부모 클래스 또는 자식 클래스 변경시, 직렬화형태도 변경되기에.

- 다만, `Throwable`같은 경우, RMI를 통해 클라이언트측에 예외를 보내기 위해 어쩔수 없이 직렬화 구현.

## Advice 2: 내부클래스(InnerClass)는 직렬화 금지

> 기본 방식의 직렬화 형태가 불분명하기에.

- 내부클래스는, 컴파일러가 추가적으로 필드를 생성한다. (바깥 인스턴스 참조용 + Scope안의 지역변수의 값 저장용)


## Advice 3: 상속용 클래스에서 직렬화를 지원하지 않아도 주의할 점 

> 하위클래스에서 직렬화를 지원한다면, 상위클래스의 기본 생성자가 필요하다.
> 
> 만약 제공하지 않는다면, 직렬화 Proxy패턴(EJ90) 이용.



# QnA

## Q. 사용중인 인스턴스 필드가 직렬화와 확장이 가능한경우의 주의점?

- if 해당 인스턴스 필드의 불변식을 보장하고 싶다면, 
	- 하위 클래스에서 `finalize()`를 재정의 하지 못하도록 `final`로 선언하라.

- if 해당 인스턴스가 기본 값(0, false, null)으로 초기화되어선 안된다면,
	- `readObjectNoData()`메서드를 추가해서 막아라.

```java
private void readObjectNoData() throws InvalidObjectException { 
	throw new InvalidObjectException("스트림 데이터가 필요합니다."); 
}
```


## Q. `serialVersionUID` ?

> Serializable 구현하는 클래스의 versioning용도로 쓰이는 고유 식별번호(long type)

- 직렬화시, 해당 값을 저장하고, 

- 역직렬화시, 해당 값을 체크하여 같은 버전의 객체인지를 확인하는 용도로 쓰인다.

- 따라서, 직렬화시의 값과, 역직렬화시의 값이 다르다면 InvalidClassException발생.

